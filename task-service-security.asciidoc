:toc: macro

= Task Service - Security

This chapter focuses on the security measures for our application, emphasizing authentication and the protection of our business logic based on user roles.

toc::[]

== Incorporating Necessary Dependency into Our Application

To utilize Spring Security, it's imperative to integrate security and its test module into our application. This can be achieved by adding the following XML configuration to the `pom.xml` file:

[source,xml]
----
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<dependency>
  <groupId>org.springframework.security</groupId>
  <artifactId>spring-security-test</artifactId>
</dependency>
----

Upon executing the application, accessing any endpoint should prompt the login screen. Additionally, a default user with the username *user* and a generated password can be found in the console. It's important to refresh the Maven model structure if any issues arise.

== Configuring Authentication

=== Creating a Security Configuration File and Basic SecurityFilterChain

* Develop a configuration class named `SecurityConfiguration`. This class will house beans utilized during authentication and authorization.
* Define a bean `SecurityFilterChain` with the following specifications:
** Allow anonymous access to the endpoints */user* adn */h2-console/***.
** Mandate authentication for all other endpoints.
** Display an auto-generated user page when not authenticated.
** Logout endpoint exists.
** Additionally enable Basic Authentication to facilitate testing endpoints easily with Postman.
** Disable CSRF (for h2-console and testing purpose) and configure frame options to be able to use h2-console

[source,java]
----
                .csrf(AbstractHttpConfigurer::disable)
                .headers(customizer -> customizer
                        .frameOptions(HeadersConfigurer.FrameOptionsConfig::sameOrigin))
----

* Establish a bean `UserDetailsService` with the following features:
** Operates in memory.
** Configures test users with selected usernames and passwords.
* Validate if the specified configurations function as intended.

[source,java]
----
@Configuration
@EnableWebSecurity
public class SecurityConfiguration {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // Implement this
    }
    
    @Bean
    public UserDetailsService userDetailsService() {
        // Implement this
    }
}
----

* Test configuration
You should be able to login as configured users when trying any of protected endpoints via login form or Basic A

== Configuring Authorization

At the beginning add annotation *@EnableMethodSecurity* to security configuration class.

Please configure the following users:

* admin - with the role *ADMIN* and *MAINTAINER*.
* maintainer - with the role *MAINTAINER*.
* user - without any role.

Now, you are prepared to safeguard your business logic. Grant access to specific user groups by employing the appropriate `@PreAuthorize` annotation (since in latest Spring version it is the one enabled by default) with the requisite permissions in your use case classes.

* *ADMIN* can create, remove and edit persons.
* *MAINTAINER* can create, remove and edit task lists and tasks.
* Users without any assigned role are permitted to read any data.

It can be done using proper SpEL expression like:
[source,java]
----
@PreAuthorize("hasRole('ADMIN')")
----

If you want to you can define static fields and use them in annotations like

[source,java]
----
@Component("Roles")
public class AccessControl {
    public static String ROLE_ADMIN = "ADMIN";
}
----

[source,java]
----
    @PreAuthorize("hasRole(@Roles.ROLE_ADMIN)")
----

Annotation for authorization can be places on Service level as in Controller level. It depends on use cases and practices used in project. In this training please put it on service implementation. Please verify the correctness of these configurations.
* Invoke endpoint by user which do not has an access to it and check response
* Do the same with user with proper roles and verify if correct action will be executed

== Fix service test

Right now all Service and some of UseCase tests will not work. They fails due to the fact that in all that endpoints we will execute service implementation which requires proper authorization. Please fix test:
* UseCases test by providing user which should be used while executing test. Please add following annotation to test on method or class level. Please remember to adjust proper role

[source,java]
----
@WithMockUser(username = "test", roles = "ADMIN")
----

* Service test can be fixed multiple way. We will extend test by adding user data and csrf in request. Some other ways can be seen in solution brach - see different test classes.  

[source,java]
----
        mockMvc.perform(delete("/person/{id}", personId)
                        .contentType(MediaType.APPLICATION_JSON)
                        .with(user("admin").roles("MAINTAINER"))
                        .with(csrf()))
                .andExpect(status().isOk());
----

== Bonus - additional tasks  (order is not relevant)

=== Storing Users in a Database

Up to this point, all user data has been stored in memory. Now, attempt to utilize a database to store user information. Adjust relevant components to retrieve data from the database during authentication.

* Create an appropriate migration script to add users and roles. Default schema can be found under *org/springframework/security/core/userdetails/jdbc/users.ddl*
* Replace the current `UserDetailsService` with one that interfaces with the database, such as *JdbcUserDetailsManager*.
* Ensure that after adding a new user to the database, logging in with the new credentials is possible.

=== Utilizing Current User Context

* Introduce a new endpoint to create a Person.
* Instead of relying on user-provided data, utilize the currently logged-in user for person details.
* For simplicity, assume that emails follow the format: `[username]@example.com`.

=== Implementing Fine-Grained Authorization

* Define more granular authorities to safeguard business logic. For example:
** CREATE_USER
** DELETE_USER
** ...
* Adjust the authorization of business logic to incorporate these new authorities.
* Establish a mapping of ROLE -> LIST_OF_AUTHORITIES. Develop a mechanism that, during authentication, resolves user roles and adds all corresponding authorities to the user.
