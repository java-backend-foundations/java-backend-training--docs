:toc: macro
toc::[]

= Order Service - Business Logic Layer

In this chapter we are going to create business logic layer for already implemented database queries. We are going to prepare UseCases together with facades and proper component tests.

== Logic layer structure

This step will contain manual creation and implementation of business logic layer. Please have in mind that most of described steps can be done by cobigen, which will be explained later on.

==== API definition

First we have to generate proper layer infrastructure. To do so we have define API for following use cases:

- UcFindItem
- UcFindCustomer
- UcFindOrder
- UcManageItem
- UcManageCustomer
- UcManageOrder

As we can see we simply define two type of usecases related to each entity we created.
Find usecases shall contain all logic related to read operations e.g. Find by id, business key, search criterions e.t.c.
Manage use cases shall contain logic for rest of CRUD functionality which modifies state of our objects and database. For example save, delete or modify methods.

Locate each of created interface in proper package:
[source,java]
----
com.devonfw.app.java.order.orderservice.logic.api.usecase 
----

==== Implementation
Now we have to define method API to fulfill logic defined in dataaccess layer. Please locate following logic in proper usecase interfaces:

- increase price of the item with specified name.
- remove customer by id.
- create order with two positions and owner specified.
- find orders from given day with specified status.
- find items by name match (LIKE) ordered by name.


Than create implementation for each of the interfaces and locate them in following package:
[source,java]
----
com.devonfw.app.java.order.orderservice.logic.impl.usecase 
----

Each of created use case has to be annotated with following annotations:
[source,java]
----
@Named
@Validated
@Transactional
----

In such created classes we can @Inject our repositories or create abstract class which contains all of mandatory repositories and inherit after that. Here’s example:

[source,java]
----
public class AbstractOrderUc extends AbstractUc {

	@Inject
	private OrderRepository orderRepository;

	public OrderRepository getOrderRepository() {

		return this.orderRepository;
	}

}
----


==== Component fasade 

Now we have to define component fasade. Component fasade will be used when we’d like to access logic defined in specific component from another one. Please define it as follow:
[source,java]
----
public interface Orderservice
		extends UcFindOrder, UcManageOrder, UcFindCustomer, UcManageCustomer, UcFindItem, UcManageItem {

}
----

Implementation of this class contain only redirection of functionality to respective usecases. We expect it to have following structure:

[source,java]
----
@Named
public class OrderserviceImpl extends AbstractComponentFacade implements Orderservice {

	@Inject
	private UcFindOrder ucFindOrder;

	// ...

	@Override
	public Page<OrderEto> findOrders(OrderSearchCriteriaTo criteria) {
		return this.ucFindOrder.findOrders(criteria);
	}

	// ...
}
				
----

==== Implementation
After proper structure definition we have to implement logic itself. Please define proper methods in respective use cases (if not done already), and implement logic used previously created repository.
Please notice that each repository method returns Entities. In business logic layer we have to convert them to TransportObject using bean mappers defined in AbstractBeanMapperSupport. Each of our Use Case implementation shall contain following tree, so we shall be able to use bean mapper functionality:
image::images/devon4j/10.BusinessLogic/BeanMapperSupport.jpg[width="323", link="images/devon4j/10.BusinessLogic /BeanMapperSupport.jpg"]

Example:
[source,java]
----
@Named
@Validated
@Transactional
public class UcFindCustomerImpl extends AbstractCustomerUc implements UcFindCustomer {

  /**
   * Logger instance.
   */
  private static final Logger LOG = LoggerFactory.getLogger(UcFindCustomerImpl.class);

  @Override
  public CustomerEto findCustomer(long id) {
    LOG.debug("Get Customer with id {} from database.", id);
    CustomerEntity foundEntity = getCustomerRepository().getOne(id);
    return getBeanMapper().map(foundEntity, CustomerEto.class);
  }

  @Override
  public Page<CustomerEto> findCustomers(CustomerSearchCriteriaTo criteria) {
    Page<CustomerEntity> customers = getCustomerRepository().findByCriteria(criteria);
    return mapPaginatedEntityList(customers, CustomerEto.class);
  }

}
----
Please notice that we are not obligated to use getters for repositories located in AbstractCustomerUc – we can simply @Inject necessary beans to our usecase implementation.

== Testing of logic layer

== Logic layer generation with Cobigen
Basically we are able to generate whole CRUD use case structures using cobigen. To do that select entity for which we want to generate code and using cobigen select following option:
image::images/devon4j/10.BusinessLogic/ CobigenLogicGeneration.jpg[width="832", link="images/devon4j/10.BusinessLogic / CobigenLogicGeneration.jpg"]

It will generate following API with implementation for Find usecase:
[source,java]
----
public interface UcFindCustomer {

	/**
	 * Returns a Customer by its id 'id'.
	 *
	 * @param id The id 'id' of the Customer.
	 * @return The {@link CustomerEto} with id 'id'
	 */
	CustomerEto findCustomer(long id);

	/**
	 * Returns a paginated list of Customers matching the search criteria.
	 *
	 * @param criteria the {@link CustomerSearchCriteriaTo}.
	 * @return the {@link List} of matching {@link CustomerEto}s.
	 */
	Page<CustomerEto> findCustomers(CustomerSearchCriteriaTo criteria);

}

----

And Manage usecase:

[source,java]
----
	/**
	 * Deletes a customer from the database by its id 'customerId'.
	 *
	 * @param customerId Id of the customer to delete
	 * @return boolean <code>true</code> if the customer can be deleted,
	 *         <code>false</code> otherwise
	 */
	boolean deleteCustomer(long customerId);

	/**
	 * Saves a customer and store it in the database.
	 *
	 * @param customer the {@link CustomerEto} to create.
	 * @return the new {@link CustomerEto} that has been saved with ID and version.
	 */
	CustomerEto saveCustomer(CustomerEto customer);
----




=== link:order-service-services-layer.asciidoc[Next chapter: Order Service - Services Layer]
